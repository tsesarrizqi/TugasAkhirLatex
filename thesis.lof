\addvspace {10\p@ }
\addvspace {10\p@ }
\contentsline {figure}{\numberline {2.1}{\ignorespaces Contoh model \textit {Convolutional Neural Network} yang mengandung lapisan konvolusi, lapisan \textit {pooling}, dan lapisan \textit {fully-connected}.\relax }}{4}{figure.caption.13}
\contentsline {figure}{\numberline {2.2}{\ignorespaces Perbedaan proses latihan dan \textit {inference} pada \textit {Deep Learning}.\relax }}{5}{figure.caption.14}
\contentsline {figure}{\numberline {2.3}{\ignorespaces Contoh operasi konvolusi.\relax }}{7}{figure.caption.15}
\contentsline {figure}{\numberline {2.4}{\ignorespaces Ilustrasi perkalian matriks-vektor pada lapisan \textit {fully-connected}, dimana elemen ke-$i$ pada vektor $weight \times input$ adalah nilai $out_i$.\relax }}{8}{figure.caption.16}
\contentsline {figure}{\numberline {2.5}{\ignorespaces Arsitektur Tensorflow Lite dengan \textit {interpreter} yang bertugas memuat \textit {kernel} yang diperlukan secara selektif.\relax }}{10}{figure.caption.17}
\contentsline {figure}{\numberline {2.6}{\ignorespaces Contoh \textit {NDRange} dua dimensi yang terdiri dari beberapa \textit {work-group} dua dimensi.\relax }}{12}{figure.caption.19}
\addvspace {10\p@ }
\contentsline {figure}{\numberline {3.1}{\ignorespaces Contoh matriks pada operasi konvolusi yang disimpan secara linear di memori GPU.\relax }}{15}{figure.caption.20}
\contentsline {figure}{\numberline {3.2}{\ignorespaces Struktur \textit {NDRange} untuk operasi konvolusi matriks.\relax }}{16}{figure.caption.21}
\contentsline {figure}{\numberline {3.3}{\ignorespaces Contoh blok pada matriks masukan yang terlibat dalam konvolusi untuk menghasilkan blok pada matriks keluaran yang diproses oleh suatu \textit {work-group}.\relax }}{16}{figure.caption.22}
\contentsline {figure}{\numberline {3.4}{\ignorespaces Operasi konvolusi yang dilakukan dalam $ceil(C_i/4)$ iterasi dimana $C_i$ adalah kedalaman matriks masukan.\relax }}{17}{figure.caption.23}
\contentsline {figure}{\numberline {3.5}{\ignorespaces Contoh \textit {local memory caching} terhadap matriks masukan pada suatu iterasi dimana \textit {work-item} dengan nomor $i$ bertugas menyalin vektor-vektor $float4$ dari matriks masukan dengan nomor $i$ ke memori lokal.\relax }}{18}{figure.caption.24}
\contentsline {figure}{\numberline {3.6}{\ignorespaces Contoh \textit {local memory caching} terhadap blok matriks filter yang terkait dengan blok matriks masukan pada suatu iterasi, dimana \textit {work-item} dengan nomor $i$ bertugas menyalin vektor-vektor $float4$ dari matriks filter dengan nomor $i$ ke memori lokal.\relax }}{19}{figure.caption.25}
\contentsline {figure}{\numberline {3.7}{\ignorespaces Contoh matriks pada pada operasi perkalian matriks-matriks yang disimpan secara linear di memori GPU.\relax }}{20}{figure.caption.26}
\contentsline {figure}{\numberline {3.8}{\ignorespaces Struktur \textit {NDRange} untuk operasi perkalian matriks-matriks.\relax }}{20}{figure.caption.27}
\contentsline {figure}{\numberline {3.9}{\ignorespaces Perkalian antara dua blok berukuran $32 \times K$ dan $K \times 32$ pada matriks A dan matriks B sehingga menghasilkan satu blok berukuran $32 \times 32$ pada matriks C.\relax }}{21}{figure.caption.28}
\contentsline {figure}{\numberline {3.10}{\ignorespaces Contoh operasi perkalian matriks-matriks yang dilakukan dalam $ceil(K/32)$ iterasi dimana setiap iterasi melibatkan blok matriks A dengan lebar 32 dan blok matriks B dengan tinggi 32.\relax }}{22}{figure.caption.29}
\contentsline {figure}{\numberline {3.11}{\ignorespaces Contoh \textit {local memory caching} pada perkalian matriks-matriks, dimana masing-masing \textit {work-item} menyalin dua vektor $float4$ (\textit {work-item} merah memuat vektor berwarna merah dan \textit {work-item} biru memuat vektor berwarna biru).\relax }}{22}{figure.caption.30}
\contentsline {figure}{\numberline {3.12}{\ignorespaces Skema modifikasi kode sumber Tensorflow Lite dengan menambahkan satu jenis \textit {kernel} baru untuk operasi perkalian matriks-matriks dan konvolusi matriks yang diimplementasikan melalui OpenCL dan berjalan di GPU.\relax }}{23}{figure.caption.31}
\contentsline {figure}{\numberline {3.13}{\ignorespaces Ilustrasi persiapan untuk OpenCL yang dilakukan hanya satu kali di awal berjalannya suatu aplikasi \textit {Deep Learning}.\relax }}{24}{figure.caption.32}
\contentsline {figure}{\numberline {3.14}{\ignorespaces Ilustrasi proses transfer data antara memori CPU dan GPU yang dilakukan setiap kali suatu operasi perkalian matriks-matriks atau konvolusi matriks pada proses \textit {inference} berlangsung.\relax }}{24}{figure.caption.33}
\addvspace {10\p@ }
\contentsline {figure}{\numberline {4.1}{\ignorespaces Hasil pengujian terhadap keseluruhan proses \textit {inference} menggunakan aplikasi pengenalan citra yang diimplementasikan menggunakan Tensorflow Lite.\relax }}{27}{figure.caption.34}
\contentsline {figure}{\numberline {4.2}{\ignorespaces Perbandingan kecepatan tiga jenis \textit {kernel} untuk operasi perkalian matriks-matriks.\relax }}{28}{figure.caption.37}
\contentsline {figure}{\numberline {4.3}{\ignorespaces Perbandingan kecepatan tiga jenis \textit {kernel} untuk operasi konvolusi matriks pada kasus ketika tinggi dan lebar matriks masukan bervariasi.\relax }}{30}{figure.caption.41}
\contentsline {figure}{\numberline {4.4}{\ignorespaces Perbandingan kecepatan tiga jenis \textit {kernel} untuk operasi konvolusi matriks pada kasus ketika kedalaman matriks masukan bervariasi.\relax }}{32}{figure.caption.45}
\contentsline {figure}{\numberline {4.5}{\ignorespaces Perbandingan kecepatan tiga jenis \textit {kernel} untuk operasi konvolusi matriks pada kasus ketika banyaknya \textit {batch} dan kanal matriks keluaran bervariasi.\relax }}{34}{figure.caption.49}
\addvspace {10\p@ }
